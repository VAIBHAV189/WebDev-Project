"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectionPool = void 0;

var mysql = _interopRequireWildcard(require("mysql"));

var _Sql = require("./Sql");

var _cliHighlight = _interopRequireDefault(require("cli-highlight"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function typeCast(field, next) {
  switch (field.type) {
    case 'DATE':
    case 'DATETIME':
    case 'DATETIME2':
    case 'NEWDATE':
    case 'TIMESTAMP':
    case 'TIMESTAMP2':
      return field.string();

    case 'LONGLONG':
      const numberString = field.string();
      return numberString === null ? null : BigInt(numberString);

    case 'BIT':
      if (field.length === 1) {
        const buf = field.buffer();
        return buf === null ? null : buf[0] === 1;
      }

      break;
  }

  return next();
}

class ConnectionPool {
  constructor(config) {
    this.config = {
      timezone: 'Z',
      charset: 'utf8mb4',
      typeCast,
      ...config
    };
    let {
      sqlMode,
      foreignKeyChecks,
      safeUpdates,
      printQueries,
      initSql,
      ...other
    } = this.config;
    this.pool = mysql.createPool(other);
    const connQueries = initSql ? [...initSql] : [];

    if (sqlMode != null) {
      connQueries.push(_Sql.sql`SET sql_mode=${Array.isArray(sqlMode) ? sqlMode.join(',') : sqlMode}`);
    }

    if (foreignKeyChecks != null) {
      connQueries.push(_Sql.sql`SET foreign_key_checks=${foreignKeyChecks ? 1 : 0}`);
    }

    if (safeUpdates) {
      connQueries.push(_Sql.sql`SET sql_safe_updates=${safeUpdates ? 1 : 0}`);
    }

    if (connQueries.length) {
      this.pool.on('connection', _conn => {
        const conn = this._wrap(_conn);

        for (const query of connQueries) {
          conn.query(query);
        }
      });
    }
  }

  query(query) {
    return this.withConnection(conn => conn.query(query));
  }

  async *stream(query) {
    const sql = query.toSqlString();

    if (this.config.printQueries) {
      const hisql = (0, _cliHighlight.default)(sql, {
        language: 'sql',
        ignoreIllegals: true
      });
      console.log(hisql);
    }

    let results = [];
    let resolve;
    let promise = new Promise(r => resolve = r);
    let done = false;
    this.pool.query(sql).on('error', err => {
      throw err;
    }).on('result', row => {
      resolve();
      results.push(row);
      promise = new Promise(r => resolve = r);
    }).on('end', () => {
      done = true;
    });

    while (!done) {
      await promise;
      yield* results;
      results = [];
    }
  }

  withConnection(callback) {
    return new Promise((resolve, reject) => {
      this.pool.getConnection(async (err, conn) => {
        if (err) return reject(err);

        try {
          resolve(callback(this._wrap(conn)));
        } finally {
          conn.release();
        }
      });
    });
  }

  transaction(callback) {
    if (Array.isArray(callback)) {
      return this.transaction(async conn => {
        const results = await Promise.allSettled(callback.map(sql => conn.query(sql)));
        const mapped = zip(callback, results).map((x, i) => ({
          index: i,
          query: x[0],
          result: x[1]
        }));
        const errors = mapped.filter(r => r.result.status === 'rejected');
        if (errors.length) throw Error(`${errors.length} quer${errors.length === 1 ? 'y' : 'ies'} failed:${errors.map(err => `\n[${err.index}] ${err.query.toSqlString()} :: ${err.result.reason}`).join('')}`);
        return results;
      });
    }

    return this.withConnection(async conn => {
      await conn.query(_Sql.sql`START TRANSACTION`);
      let result;

      try {
        result = await callback(conn);
      } catch (err) {
        await conn.query(_Sql.sql`ROLLBACK`);
        throw err;
      }

      await conn.query(_Sql.sql`COMMIT`);
      return result;
    });
  }

  _wrap(conn) {
    return new PoolConnection(conn, !!this.config.printQueries);
  }

  close() {
    return new Promise((resolve, reject) => {
      this.pool.end(err => {
        if (err) return reject(err);
        resolve();
      });
    });
  }

}

exports.ConnectionPool = ConnectionPool;

function zip(a, b) {
  if (a.length !== b.length) throw new Error("Cannot zip arrays; lengths differ");
  return a.map((x, i) => [x, b[i]]);
}

class PoolConnection {
  constructor(conn, printQueries) {
    this.conn = conn;
    this.printQueries = printQueries;
  }

  query(query) {
    return new Promise((resolve, reject) => {
      const sql = query.toSqlString();

      if (this.printQueries) {
        const hisql = (0, _cliHighlight.default)(sql, {
          language: 'sql',
          ignoreIllegals: true
        });
        console.log(hisql);
      }

      this.conn.query(sql, (error, results, fields) => {
        if (error) return reject(error);
        resolve(results);
      });
    });
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Db25uZWN0aW9uUG9vbC50cyJdLCJuYW1lcyI6WyJ0eXBlQ2FzdCIsImZpZWxkIiwibmV4dCIsInR5cGUiLCJzdHJpbmciLCJudW1iZXJTdHJpbmciLCJCaWdJbnQiLCJsZW5ndGgiLCJidWYiLCJidWZmZXIiLCJDb25uZWN0aW9uUG9vbCIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwidGltZXpvbmUiLCJjaGFyc2V0Iiwic3FsTW9kZSIsImZvcmVpZ25LZXlDaGVja3MiLCJzYWZlVXBkYXRlcyIsInByaW50UXVlcmllcyIsImluaXRTcWwiLCJvdGhlciIsInBvb2wiLCJteXNxbCIsImNyZWF0ZVBvb2wiLCJjb25uUXVlcmllcyIsInB1c2giLCJzcWwiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwib24iLCJfY29ubiIsImNvbm4iLCJfd3JhcCIsInF1ZXJ5Iiwid2l0aENvbm5lY3Rpb24iLCJzdHJlYW0iLCJ0b1NxbFN0cmluZyIsImhpc3FsIiwibGFuZ3VhZ2UiLCJpZ25vcmVJbGxlZ2FscyIsImNvbnNvbGUiLCJsb2ciLCJyZXN1bHRzIiwicmVzb2x2ZSIsInByb21pc2UiLCJQcm9taXNlIiwiciIsImRvbmUiLCJlcnIiLCJyb3ciLCJjYWxsYmFjayIsInJlamVjdCIsImdldENvbm5lY3Rpb24iLCJyZWxlYXNlIiwidHJhbnNhY3Rpb24iLCJhbGxTZXR0bGVkIiwibWFwIiwibWFwcGVkIiwiemlwIiwieCIsImkiLCJpbmRleCIsInJlc3VsdCIsImVycm9ycyIsImZpbHRlciIsInN0YXR1cyIsIkVycm9yIiwicmVhc29uIiwiUG9vbENvbm5lY3Rpb24iLCJjbG9zZSIsImVuZCIsImEiLCJiIiwiZXJyb3IiLCJmaWVsZHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7QUE4Q0EsU0FBU0EsUUFBVCxDQUFrQkMsS0FBbEIsRUFBb0NDLElBQXBDLEVBQXVEO0FBQ25ELFVBQVFELEtBQUssQ0FBQ0UsSUFBZDtB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SixFQUFXLE9BQU90QixNQUFNLENBQUNzQixLQUFELENBQWI7QUFDWDlCLFFBQUFBLE9BQU8sQ0FBQ0QsT0FBRCxDQUFQO0FBQ0gsT0FIRDtBQUlILEtBVk0sQ0FBUDtBQVdIOztBQWxCZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBteXNxbCBmcm9tICdteXNxbCc7XG5pbXBvcnQge1Bvb2xDb25maWcgYXMgX1Bvb2xDb25maWcsIFBvb2wsIFR5cGVDYXN0IGFzIF9UeXBlQ2FzdCwgRmllbGRJbmZvIGFzIF9GaWVsZEluZm8sIFR5cGVzIGFzIF9UeXBlc30gZnJvbSBcIm15c3FsXCI7XG5pbXBvcnQge3NxbCwgU3FsRnJhZ30gZnJvbSAnLi9TcWwnO1xuaW1wb3J0IGhpZ2hsaWdodCBmcm9tICdjbGktaGlnaGxpZ2h0JztcbmltcG9ydCB7aW5zcGVjdH0gZnJvbSBcInV0aWxcIjtcbmltcG9ydCB7R2VvbWV0cnlUeXBlfSBmcm9tIFwibXlzcWxcIjtcbmltcG9ydCBTcWxNb2RlIGZyb20gXCIuL1NxbE1vZGVcIjtcbmltcG9ydCB7UG9vbENvbm5lY3Rpb24gYXMgX1Bvb2xDb25uZWN0aW9ufSBmcm9tIFwibXlzcWxcIjtcblxuZXhwb3J0IGludGVyZmFjZSBQb29sQ29uZmlnIGV4dGVuZHMgT21pdDxfUG9vbENvbmZpZywndHlwZUNhc3QnfCdzdXBwb3J0QmlnTnVtYmVycyd8J2JpZ051bWJlclN0cmluZ3MnPiB7XG4gICAgLyoqXG4gICAgICogUHJpbnQgU1FMIHF1ZXJpZXMgdG8gU1RET1VUIGJlZm9yZSBleGVjdXRpbmcgdGhlbS5cbiAgICAgKi9cbiAgICBwcmludFF1ZXJpZXM/OiBib29sZWFuXG4gICAgdHlwZUNhc3Q/OiAoZmllbGQ6IEZpZWxkSW5mbywgbmV4dDogTmV4dEZuKSA9PiBhbnksXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgU2V0IGluIG15LmNuZiB1bmRlciBbbXlzcWxkXVxuICAgICAqL1xuICAgIHNxbE1vZGU/OiBTcWxNb2RlW118c3RyaW5nfG51bGwsXG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgZm9yZWlnbiBrZXkgY2hlY2tzIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLiBNYXkgZWFzZSBtaWdyYXRpb24gc2NyaXB0cywgYnV0IG5vdCByZWNvbW1lbmRlZFxuICAgICAqIGZvciBwcm9kdWN0aW9uIHVzYWdlLlxuICAgICAqL1xuICAgIGZvcmVpZ25LZXlDaGVja3M/OiBib29sZWFufG51bGwsXG4gICAgLyoqXG4gICAgICogSWYgdGhpcyB2YXJpYWJsZSBpcyBlbmFibGVkLCBVUERBVEUgYW5kIERFTEVURSBzdGF0ZW1lbnRzIHRoYXQgZG8gbm90IHVzZSBhIGtleSBpbiB0aGUgV0hFUkUgY2xhdXNlIG9yIGEgTElNSVQgY2xhdXNlIHByb2R1Y2UgYW4gZXJyb3IuIFRoaXMgbWFrZXMgaXQgcG9zc2libGUgdG8gY2F0Y2ggVVBEQVRFIGFuZCBERUxFVEUgc3RhdGVtZW50cyB3aGVyZSBrZXlzIGFyZSBub3QgdXNlZCBwcm9wZXJseSBhbmQgdGhhdCB3b3VsZCBwcm9iYWJseSBjaGFuZ2Ugb3IgZGVsZXRlIGEgbGFyZ2UgbnVtYmVyIG9mIHJvd3MuXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL21hcmlhZGIuY29tL2tiL2VuL2xpYnJhcnkvc2VydmVyLXN5c3RlbS12YXJpYWJsZXMvI3NxbF9zYWZlX3VwZGF0ZXNcbiAgICAgKiBAbGluayBodHRwczovL2Rldi5teXNxbC5jb20vZG9jL3JlZm1hbi84LjAvZW4vc2VydmVyLXN5c3RlbS12YXJpYWJsZXMuaHRtbCNzeXN2YXJfc3FsX3NhZmVfdXBkYXRlc1xuICAgICAqIEBkZXByZWNhdGVkIFNldCBpbiBteS5jbmYgdW5kZXIgW215c3FsZF1cbiAgICAgKi9cbiAgICBzYWZlVXBkYXRlcz86IGJvb2xlYW58bnVsbCxcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBTUUwgc3RhdGVtZW50cyB0byBleGVjdXRlIHVwb24gY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBpbml0U3FsPzogQXJyYXk8U3FsRnJhZz5cbn1cblxuZXhwb3J0IHR5cGUgTmV4dEZuID0gKCkgPT4gdm9pZFxuZXhwb3J0IHR5cGUgVHlwZXMgPSBrZXlvZiB0eXBlb2YgX1R5cGVzXG5leHBvcnQgdHlwZSBGaWVsZEluZm8gPSBPbWl0PF9GaWVsZEluZm8sICd0eXBlJz4gJiB7XG4gICAgdHlwZTogVHlwZXMsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgc3RyaW5nKCk6IHN0cmluZyB8IG51bGwsXG4gICAgYnVmZmVyKCk6IEJ1ZmZlciB8IG51bGwsXG4gICAgZ2VvbWV0cnkoKTogR2VvbWV0cnlUeXBlIHwgbnVsbCxcbn1cblxuXG5mdW5jdGlvbiB0eXBlQ2FzdChmaWVsZDogRmllbGRJbmZvLCBuZXh0OiBOZXh0Rm4pOiBhbnkge1xuICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICBjYXNlICdEQVRFJzpcbiAgICAgICAgY2FzZSAnREFURVRJTUUnOlxuICAgICAgICBjYXNlICdEQVRFVElNRTInOlxuICAgICAgICBjYXNlICdORVdEQVRFJzpcbiAgICAgICAgY2FzZSAnVElNRVNUQU1QJzpcbiAgICAgICAgY2FzZSAnVElNRVNUQU1QMic6XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXlzcWxqcy9teXNxbCN0eXBlLWNhc3RpbmdcbiAgICAgICAgICAgIHJldHVybiBmaWVsZC5zdHJpbmcoKTtcbiAgICAgICAgY2FzZSAnTE9OR0xPTkcnOlxuICAgICAgICAgICAgY29uc3QgbnVtYmVyU3RyaW5nID0gZmllbGQuc3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyU3RyaW5nID09PSBudWxsID8gbnVsbCA6IEJpZ0ludChudW1iZXJTdHJpbmcpO1xuICAgICAgICBjYXNlICdCSVQnOlxuICAgICAgICAgICAgaWYgKGZpZWxkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IGZpZWxkLmJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWYgPT09IG51bGwgPyBudWxsIDogYnVmWzBdID09PSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG59XG5cbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uUG9vbCB7XG4gICAgcHJpdmF0ZSBwb29sOiBQb29sO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBQb29sQ29uZmlnO1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBQb29sQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgdGltZXpvbmU6ICdaJyxcbiAgICAgICAgICAgIGNoYXJzZXQ6ICd1dGY4bWI0JyxcbiAgICAgICAgICAgIHR5cGVDYXN0LFxuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICBsZXQge3NxbE1vZGUsZm9yZWlnbktleUNoZWNrcyxzYWZlVXBkYXRlcyxwcmludFF1ZXJpZXMsaW5pdFNxbCwuLi5vdGhlcn0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgdGhpcy5wb29sID0gbXlzcWwuY3JlYXRlUG9vbChvdGhlcik7XG5cbiAgICAgICAgY29uc3QgY29ublF1ZXJpZXMgPSBpbml0U3FsID8gWy4uLmluaXRTcWxdIDogW107XG4gICAgICAgIGlmKHNxbE1vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29ublF1ZXJpZXMucHVzaChzcWxgU0VUIHNxbF9tb2RlPSR7QXJyYXkuaXNBcnJheShzcWxNb2RlKSA/ICBzcWxNb2RlLmpvaW4oJywnKSA6IHNxbE1vZGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZm9yZWlnbktleUNoZWNrcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25uUXVlcmllcy5wdXNoKHNxbGBTRVQgZm9yZWlnbl9rZXlfY2hlY2tzPSR7Zm9yZWlnbktleUNoZWNrcyA/IDEgOiAwfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmKHNhZmVVcGRhdGVzKSB7XG4gICAgICAgICAgICBjb25uUXVlcmllcy5wdXNoKHNxbGBTRVQgc3FsX3NhZmVfdXBkYXRlcz0ke3NhZmVVcGRhdGVzID8gMSA6IDB9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoY29ublF1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvb2wub24oJ2Nvbm5lY3Rpb24nLCAoX2Nvbm46IF9Qb29sQ29ubmVjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLl93cmFwKF9jb25uKTtcbiAgICAgICAgICAgICAgICBmb3IoY29uc3QgcXVlcnkgb2YgY29ublF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubi5xdWVyeShxdWVyeSk7IC8vIFRPRE86IGRvIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlc2UgcXVlcmllcyB0byBmaW5pc2guLi4/XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeTxUUmVjb3JkIGV4dGVuZHMgb2JqZWN0PVJlY29yZDxzdHJpbmcsYW55Pj4ocXVlcnk6IFNxbEZyYWcpOiBQcm9taXNlPFRSZWNvcmRbXT4ge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoQ29ubmVjdGlvbihjb25uID0+IGNvbm4ucXVlcnkocXVlcnkpKVxuICAgIH1cblxuXG4gICAgYXN5bmMqIHN0cmVhbTxUUmVjb3JkIGV4dGVuZHMgb2JqZWN0ID0gUmVjb3JkPHN0cmluZywgYW55Pj4ocXVlcnk6IFNxbEZyYWcpOiBBc3luY0dlbmVyYXRvcjxUUmVjb3JkLCB2b2lkLCBhbnk+IHtcbiAgICAgICAgY29uc3Qgc3FsID0gcXVlcnkudG9TcWxTdHJpbmcoKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcucHJpbnRRdWVyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBoaXNxbCA9IGhpZ2hsaWdodChzcWwsIHtsYW5ndWFnZTogJ3NxbCcsIGlnbm9yZUlsbGVnYWxzOiB0cnVlfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhoaXNxbCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0czogVFJlY29yZFtdID0gW107XG4gICAgICAgIGxldCByZXNvbHZlOiAoKSA9PiB2b2lkO1xuICAgICAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHIgPT4gcmVzb2x2ZSA9IHIpO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucG9vbC5xdWVyeShzcWwpXG4gICAgICAgICAgICAub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdyZXN1bHQnLCByb3cgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UociA9PiByZXNvbHZlID0gcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIHlpZWxkKiByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2l0aENvbm5lY3Rpb248VFJlc3VsdD4oY2FsbGJhY2s6IChjb25uOlBvb2xDb25uZWN0aW9uKSA9PiBQcm9taXNlPFRSZXN1bHQ+KTogUHJvbWlzZTxUUmVzdWx0PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvb2wuZ2V0Q29ubmVjdGlvbihhc3luYyAoZXJyLCBjb25uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY2FsbGJhY2sodGhpcy5fd3JhcChjb25uKSkpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm4ucmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYW5zYWN0aW9uPFRSZXN1bHQ+KGNhbGxiYWNrOiAoKGNvbm46UG9vbENvbm5lY3Rpb24pID0+IFByb21pc2U8VFJlc3VsdD4pfFNxbEZyYWdbXSk6IFByb21pc2U8VFJlc3VsdD4ge1xuICAgICAgICBpZihBcnJheS5pc0FycmF5KGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb248YW55Pihhc3luYyBjb25uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGNhbGxiYWNrLm1hcChzcWwgPT4gY29ubi5xdWVyeShzcWwpKSlcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWQgPSB6aXAoY2FsbGJhY2ssIHJlc3VsdHMpLm1hcCgoeCxpKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHhbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogeFsxXSxcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBtYXBwZWQuZmlsdGVyKHIgPT4gci5yZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICBpZihlcnJvcnMubGVuZ3RoKSB0aHJvdyBFcnJvcihgJHtlcnJvcnMubGVuZ3RofSBxdWVyJHtlcnJvcnMubGVuZ3RoID09PSAxID8gJ3knIDogJ2llcyd9IGZhaWxlZDoke2Vycm9ycy5tYXAoZXJyID0+IGBcXG5bJHtlcnIuaW5kZXh9XSAke2Vyci5xdWVyeS50b1NxbFN0cmluZygpfSA6OiAkeyhlcnIucmVzdWx0IGFzIGFueSkucmVhc29ufWApLmpvaW4oJycpfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzOyAvLyBUT0RPOiBpcyB0aGlzIHRoZSBiZXN0IGZvcm1hdCBmb3IgdGhlIHJlc3VsdHM/XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoQ29ubmVjdGlvbihhc3luYyBjb25uID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoc3FsYFNUQVJUIFRSQU5TQUNUSU9OYCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0OiBUUmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBjYWxsYmFjayhjb25uKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShzcWxgUk9MTEJBQ0tgKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KHNxbGBDT01NSVRgKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfd3JhcChjb25uOiBfUG9vbENvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb29sQ29ubmVjdGlvbihjb25uLCAhIXRoaXMuY29uZmlnLnByaW50UXVlcmllcyk7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvb2wuZW5kKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5mdW5jdGlvbiB6aXA8QSxCPihhOiBBW10sIGI6IEJbXSk6IEFycmF5PFtBLEJdPiB7XG4gICAgaWYoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgemlwIGFycmF5czsgbGVuZ3RocyBkaWZmZXJcIik7XG4gICAgcmV0dXJuIGEubWFwKCh4LGkpID0+IFt4LGJbaV1dKTtcbn1cblxuY2xhc3MgUG9vbENvbm5lY3Rpb24ge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBjb25uOiBfUG9vbENvbm5lY3Rpb24sIHByaXZhdGUgcmVhZG9ubHkgcHJpbnRRdWVyaWVzOiBib29sZWFuKSB7XG5cbiAgICB9XG5cbiAgICBxdWVyeTxUUmVjb3JkIGV4dGVuZHMgb2JqZWN0PVJlY29yZDxzdHJpbmcsYW55Pj4ocXVlcnk6IFNxbEZyYWcpOiBQcm9taXNlPFRSZWNvcmRbXT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3FsID0gcXVlcnkudG9TcWxTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByaW50UXVlcmllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhpc3FsID0gaGlnaGxpZ2h0KHNxbCwge2xhbmd1YWdlOiAnc3FsJywgaWdub3JlSWxsZWdhbHM6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhoaXNxbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm4ucXVlcnkoc3FsLCAoZXJyb3IsIHJlc3VsdHMsIGZpZWxkcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxufVxuIl19